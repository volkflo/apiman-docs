<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>apiman - Developer Guide :: Apiman Documentation</title>
    <link rel="canonical" href="https://volkflo.github.io/apiman-docs/core/latest/development/Guide.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-56678850-3"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','UA-56678850-3')</script>
    <script>var uiRootPath = '../../../_'</script>
<link rel="icon" href="../../../_/img/apiman/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div id="apiman-logo"></div>
    <div class="navbar-brand">
      <a class="navbar-item" href="https://volkflo.github.io/apiman-docs">Apiman Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://www.apiman.io/latest/index.html">Home</a>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="https://www.apiman.io/latest/download.html">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="core" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="Guide.html">Apiman Development Guide</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="Guide.html">Guide</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Gateway.html">Gateway</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Plugins.html">Plugins</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="Resources.html">Resources</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Apiman Development Guide</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="Guide.html">Apiman Development Guide</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="Guide.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../installation-guide/latest/index.html">Apiman Installation Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../installation-guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../user-guide/latest/index.html">Apiman User Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../user-guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../welcome/latest/index.html">Apiman Welcome</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../welcome/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../welcome/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="Guide.html">Apiman Development Guide</a></li>
    <li><a href="Guide.html">Guide</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/apiman/apiman/edit/antora-updated/docs/modules/ROOT/pages/development/Guide.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">apiman - Developer Guide</h1>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Are you interested in contributing to the development of apiman?  Maybe you want to embed the
project in your own solution?  In either case this is the guide for you.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_developer_resources"><a class="anchor" href="#_developer_resources"></a>Developer Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes a number of resources that are useful if you wish to contribute
code to apiman.  It is likely also a good starting point for those wishing to provide
functionality by implementing a plugin, although more information about plugins can
be found in the 'Plugins' section.</p>
</div>
<div class="sect2">
<h3 id="_source_code"><a class="anchor" href="#_source_code"></a>Source Code</h3>
<div class="paragraph">
<p>The apiman source code is located in github here:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/apiman/apiman" class="bare">https://github.com/apiman/apiman</a></p>
</div>
<div class="paragraph">
<p>Source code for the apiman policies can be found here:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/apiman/apiman-plugins" class="bare">https://github.com/apiman/apiman-plugins</a></p>
</div>
<div class="paragraph">
<p>Source code for the apiman project web site is here:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/apiman/apiman.github.io" class="bare">https://github.com/apiman/apiman.github.io</a></p>
</div>
<div class="paragraph">
<p>The official apiman docker files are currently here:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/jboss-dockerfiles/apiman" class="bare">https://github.com/jboss-dockerfiles/apiman</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_issue_tracking"><a class="anchor" href="#_issue_tracking"></a>Issue Tracking</h3>
<div class="paragraph">
<p>The apiman project uses JIRA to track issues such as bugs and feature requests.  It&#8217;s a good place to start
if you&#8217;re trying to figure out how to get involved!</p>
</div>
<div class="paragraph">
<p><a href="https://issues.jboss.org/browse/APIMAN" class="bare">https://issues.jboss.org/browse/APIMAN</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_development_tools"><a class="anchor" href="#_development_tools"></a>Development Tools</h3>
<div class="paragraph">
<p>We&#8217;re rather IDE agnostic, so contributors should feel free to use whatever tools they feel most
comfortable with.  At the time of this writing, the core apiman developers primarily use Eclipse
Kepler.</p>
</div>
<div class="paragraph">
<p><a href="http://www.eclipse.org/downloads/" class="bare">http://www.eclipse.org/downloads/</a></p>
</div>
<div class="paragraph">
<p>The core apiman project is built using maven.  Currently we recommend at least version 3.0.3.</p>
</div>
<div class="paragraph">
<p><a href="http://maven.apache.org/download.cgi" class="bare">http://maven.apache.org/download.cgi</a></p>
</div>
<div class="paragraph">
<p>And of course you&#8217;ll need to have git installed if you want to check out the code from github.</p>
</div>
<div class="paragraph">
<p><a href="http://git-scm.com/" class="bare">http://git-scm.com/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_building_the_project"><a class="anchor" href="#_building_the_project"></a>Building the Project</h3>
<div class="paragraph">
<p>Building apiman should be a simple matter of doing a standard Maven build:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mvn clean install</pre>
</div>
</div>
<div class="paragraph">
<p>This will do a full build of apiman and execute all unit tests.  However,
the result will not include a ready-to-run version of apiman.  For that, you
may want to try the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>mvn clean install -Pinstall-all-wildfly9</pre>
</div>
</div>
<div class="paragraph">
<p>This command will do a full apiman build, but will also download WildFly 9
and install apiman into it.  The result will be a fully configured install of
apiman running in WildFly.  The location of this WildFly install will be here:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>apiman/tools/server-all/target/wildfly-{wildfly.version}/</pre>
</div>
</div>
<div class="paragraph">
<p>At this point you can test apiman by simply running WildFly 9 from the above
location using a command something like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>./bin/standalone.sh -b 0.0.0.0</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_setting_up_a_development_environment"><a class="anchor" href="#_setting_up_a_development_environment"></a>Setting up a Development Environment</h3>
<div class="paragraph">
<p>Because apiman is a fairly standard maven project, it should be relatively easy
to import the project into Eclipse or IntelliJ IDEA.  For now we&#8217;ll leave this
as an exercise for the reader.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_architecture"><a class="anchor" href="#_architecture"></a>Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The basic architecture of apiman is fairly straightforward.  There are several WARs that
make up the default apiman installation.  These include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API Manager REST back-end (JAX-RS WAR)</p>
</li>
<li>
<p>API Manager UI (AngularJS/Hawtio WAR)</p>
</li>
<li>
<p>API Gateway Config (JAX-RS WAR)</p>
</li>
<li>
<p>API Gateway (Servlet WAR)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The API Manager REST back-end WAR is responsible for exposing a set of REST endpoints that
make up the API Manager REST interface.  The API Manager UI uses this REST API
directly when the user manages the various entities in the data model.</p>
</div>
<div class="paragraph">
<p>The API Manager UI is a client-only AngularJS application.  Aside from authentication
related activities, this WAR only contains HTML, JavaScript, and CSS.  The UI uses
the browser to make direct, authenticated calls to the REST endpoints exposed by the
API Manager REST back-end WAR.</p>
</div>
<div class="paragraph">
<p>The API Gateway Config exposes the standard apiman Gateway REST API so that the API
Gateway can be remotely configured.  This is the REST API that the API Manager uses
whenever a user publishes an API or registers a Client App.  It is responsible
for configuring the API Gateway&#8217;s embedded Policy Engine.</p>
</div>
<div class="paragraph">
<p>The API Gateway is the primary runtime component of apiman and is implemented as a
servlet that embeds the apiman Policy Engine.  All requests to the API Gateway WAR are
assumed to be intended for managed APIs previously published to it.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_plugins"><a class="anchor" href="#_plugins"></a>Plugins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The easiest way to extend the functionality of apiman is by implementing an apiman
plugin.  This section details how this is done and what functionality can be
extended or provided.</p>
</div>
<div class="sect2">
<h3 id="_creating_a_plugin"><a class="anchor" href="#_creating_a_plugin"></a>Creating a Plugin</h3>
<div class="paragraph">
<p>An apiman plugin is basically a java web archive (WAR) with a little bit of extra
sauce.  This approach makes it very easy to build using maven, and should be quite
familiar to most Java developers.  Because a plugin consists of some resources files,
compiled java classes, front-end resource such as HTML and javascript, and dependencies
in the form of JARs, the WAR format is a natural choice.</p>
</div>
<div class="sect3">
<h4 id="_the_plugin_specification_file"><a class="anchor" href="#_the_plugin_specification_file"></a>The Plugin Specification File</h4>
<div class="paragraph">
<p>In addition to the standard layout of a Java Web Archive, an apiman plugin must contain
the following plugin specification file (which contains information about the plugin):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>META-INF/apiman/plugin.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>This 'plugin.json' file contains the basic meta-data that describes the plugin, and
should be of the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "frameworkVersion" : 1.0,
  "name" : "Plugin Name",
  "description" : "A plugin description goes here.",
  "version" : "3.1.9"
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>frameworkVersion</strong>: Indicates the apiman plugin framework version this plugin is compatible with - this should simply be 1.0 for now (reserved for future use)</p>
</li>
<li>
<p><strong>name</strong>: The name of the plugin.</p>
</li>
<li>
<p><strong>description</strong>: The description of the plugin.</p>
</li>
<li>
<p><strong>version</strong>: The plugin version.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If this 'plugin.json' file is missing from the plugin archive, then the plugin will
fail to load.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_maven_to_create_a_plugin"><a class="anchor" href="#_using_maven_to_create_a_plugin"></a>Using Maven to Create a Plugin</h4>
<div class="paragraph">
<p>One benefit of using WAR as the format of an apiman plugin is that plugins can easily
be created using Maven.  This section will describe how this can be done.  Note that
you can use the following simple plugin as a reference if you prefer:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/apiman/apiman-plugins/tree/master/noop-policy" class="bare">https://github.com/apiman/apiman-plugins/tree/master/noop-policy</a></p>
</div>
<div class="paragraph">
<p>In order to create an apiman plugin using maven, simply create a new maven project
and set its 'packaging' type to <strong>war</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;packaging&gt;war&lt;/packaging&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, obviously feel free to include any dependencies you might need:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
  &lt;!-- apiman dependencies (must be excluded from the WAR) --&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;io.apiman&lt;/groupId&gt;
    &lt;artifactId&gt;apiman-gateway-engine-core&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll want to make any apiman dependencies provided so that there aren&#8217;t any classloading
conflicts when executing your code.</p>
</div>
<div class="paragraph">
<p>Finally, we recommend that you put your plugin.json file in the following location
in your maven project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/main/apiman</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, any resoures in that location are not automatially included in the final
WAR, so you should add the following markup to your pom.xml:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
      &lt;configuration&gt;
        &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
        &lt;webResources&gt;
          &lt;resource&gt;
            &lt;directory&gt;src/main/apiman&lt;/directory&gt;
            &lt;targetPath&gt;META-INF/apiman&lt;/targetPath&gt;
            &lt;filtering&gt;true&lt;/filtering&gt;
          &lt;/resource&gt;
        &lt;/webResources&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This markup will ensure that resources in the <strong>src/main/apiman</strong> folder will be included
in the correct location in the WAR.  Also note that resource filtering is enabled,
which will make it easier to maintain your <strong>plugin.json</strong> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "frameworkVersion" : 1.0,
  "name" : "My Plugin Name",
  "description" : "My plugin description.",
  "version" : "${project.version}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the 'version' of the plugin is set to <strong>${project.version}</strong>, which will get
automatically changed to the version of your maven project at build time.</p>
</div>
</div>
<div class="sect3">
<h4 id="_making_your_plugin_available_to_apiman"><a class="anchor" href="#_making_your_plugin_available_to_apiman"></a>Making Your Plugin Available to apiman</h4>
<div class="paragraph">
<p>Plugins are identified by their Maven coordinates (groupId, artifactId, version,
classifier, type).  Note that the classifier and type are optional.  If the type is
not specified when loading a plugin, apiman will assume 'war'.</p>
</div>
<div class="paragraph">
<p>When loading a plugin for use, apiman will first check for the plugin in the local
user&#8217;s .m2 directory.  This is useful when running apiman during development, but
is unlikely to be available in a production environment.  If the plugin cannot be
found locally, apiman will attempt to download it from a remote repository such as
Maven Central.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can configure additional remote repositories when you set up apiman.
Please refer to the Installation Guide for details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This all means that when testing your plugin locally, you can simply use maven to install
it into your local .m2 directory and then ask apiman to load it.  In production, the
plugin will need to be available from a remote maven repository.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_contributing_a_policy"><a class="anchor" href="#_contributing_a_policy"></a>Contributing a Policy</h3>
<div class="paragraph">
<p>Now that you know how to create an apiman plugin, you might be wondering what you can
actually do with it!  The most important purpose of a plugin is to provide additional
<strong>Policies</strong> that can be used when configuring Plans, APIs, and Client Apps in
apiman.  Although apiman comes with a set of useful built-in policies, it is often
necessary for users to provide their own custom policies.  The best way to do that is
to create a plugin that provides such policies.</p>
</div>
<div class="paragraph">
<p>In order to provide a custom policy from a plugin, several things are needed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An implementation of IPolicy (Java code)</p>
</li>
<li>
<p>A policy definition (JSON file)</p>
</li>
<li>
<p>An optional policy configuration form that the API Manager UI will present to the user when configuring the policy</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next few sections explain each of these elements further, but note that they are
all included in the apiman plugin WAR.</p>
</div>
<div class="sect3">
<h4 id="_policy_implementation"><a class="anchor" href="#_policy_implementation"></a>Policy Implementation</h4>
<div class="paragraph">
<p>A policy implementation is the java code that is executed by the API Gateway when
a managed API request is made.  This is the bread and butter of the API Gateway; its
primary purpose.  For each request, the API Gateway creates a chain of policies that
must be executed before proxying the request to the back-end API implementation.
Each of the policies in that chain is an implementation of the 'IPolicy' interface.</p>
</div>
<div class="sect4">
<h5 id="_standard_ipolicy"><a class="anchor" href="#_standard_ipolicy"></a>Standard IPolicy</h5>
<div class="paragraph">
<p>All policies must implement the <code>IPolicy</code> interface, consisting of several methods.</p>
</div>
<div class="paragraph">
<p>The <code>apply</code> method with <code>ApiRequest</code> is called during the request phase, and
the <code>apply</code> with <code>ApiResponse</code> during the response phase:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void apply(ApiRequest request, IPolicyContext context, Object config, IPolicyChain&lt;ApiRequest&gt; chain);

void apply(ApiResponse response, IPolicyContext context, Object config, IPolicyChain&lt;ApiResponse&gt; chain);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API objects, respectively, provide abstracted representations of the head
of a request and response for a given conversation. These can be modified in any
manner the implementor sees fit.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Policy instances are stateless, so it is not a good idea to use fields for any
reason.  The IPolicyContext can be used to pass information from the request phase
to the response phase.  Any state that must span multiple requests will need to use
one of the policy components described in the <strong>Provided Components</strong> section.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Object parseConfiguration(String jsonConfiguration) throws ConfigurationParseException;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final <code>IPolicy</code> method is used to parse JSON configuration into an arbitrary
object configuration which will be passed in in its parsed form to <code>doApply</code>, where
the implementor may cast it their native configuration object.  This method will
be invoked for each unique configuration of the policy.</p>
</div>
<div class="paragraph">
<p>For mroe information about policy configuration, see the <strong>Policy Configuration</strong> section
below.</p>
</div>
<div class="sect5">
<h6 id="_indicating_successes"><a class="anchor" href="#_indicating_successes"></a>Indicating Successes</h6>
<div class="paragraph">
<p>If a policy determines that the conversation can continue, <code>chain.doApply</code> should
be signalled. Any modifications you wish to pass onto the next policy should be
completed and included in the invocation.</p>
</div>
</div>
<div class="sect5">
<h6 id="_indicating_failures"><a class="anchor" href="#_indicating_failures"></a>Indicating Failures</h6>
<div class="paragraph">
<p>If it is determined that a conversation should be interrupted for governance reasons
(i.e. according to business logic and not exceptional), then <code>chain.doFailure</code> should
be signalled. A useful <code>PolicyFailure</code> should be provided, which allows gateways to
respond in a sensible way to the requestor.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The platform&#8217;s <code>IPolicyFailureFactoryComponent</code> can be used to generate failures.
See the <strong>Provided Components</strong> section for more details on this component.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_handling_exceptions"><a class="anchor" href="#_handling_exceptions"></a>Handling Exceptions</h6>
<div class="paragraph">
<p>As a factor of the asynchronous nature of apiman, any exceptions that may occur during
the operation of a policy should be caught and explicitly handed to <code>chain.doError</code>.
If exceptions are left uncaught, then it is possible that they will be lost.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_idata_policy"><a class="anchor" href="#_idata_policy"></a>IData Policy</h5>
<div class="paragraph">
<p>Whilst standard policies are concerned only with the head of the conversation, it
is also possible for policies to access and manipulate the body in transit. A data
policy must implement the <code>IDataPolicy</code> interface.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Handling of data streams is a performance sensitive area, implementors
should strive to be as efficient as possible and avoid any unnecessary interactions
with the stream.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>getRequestDataHandler</code> and <code>getResponseDataHandler</code> methods are the data
corollaries of <code>apply</code>. Implementors must return <code>IReadWriteStream</code> streams, which
apiman uses to write data chunks into policies, and the policies write data to
subsequent policies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IReadWriteStream&lt;ApiRequest&gt; getRequestDataHandler(ApiRequest request, IPolicyContext context);

IReadWriteStream&lt;ApiResponse&gt; getResponseDataHandler(ApiResponse response, IPolicyContext context);</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Do not return an <code>IApimanBuffer</code> with a different native type than you
received. Instantiate new buffers using the <code>IBufferFactoryComponent</code> (refer to <a href="#_provided_components">Provided Components</a>)
and prefer append patterns where possible.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Implementors must explicitly hand each chunk onto apiman when they are finished
interacting with it. A convenient way to achieve this is via <code>AbstractStream&lt;H&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Override
public IReadWriteStream&lt;ApiRequest&gt; getRequestDataHandler(final ApiRequest request, final IPolicyContext context) {
  return new AbstractStream&lt;ApiRequest&gt;() {
    @Override
    public void write(IApimanBuffer chunk) {
      // Mutate chunk by appending a string.
      chunk.append("my modification");
      // We're finished: write the chunk back to apiman
      // using super.write().
      super.write(chunk);
    }

    @Override
    public void end() {
      // End of stream signalled, do cleanup, etc.
      super.end();
    }
  };
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Do not mutate an <code>IApimanBuffer</code> once handed over.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The request or response body will not begin streaming before the corresponding <code>doApply</code>
has been called, however, it is still possible to interrupt the conversation during
the streaming phase by signalling <code>doFailure</code> or <code>doError</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_performance_considerations"><a class="anchor" href="#_performance_considerations"></a>Performance Considerations</h5>
<div class="paragraph">
<p>Policies are amongst the most impactful elements of the system for performance. To
minimise the impact of a policy implementors may wish to follow these guidelines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maintain as little state within a policy instance as possible.</p>
</li>
<li>
<p>Call <code>doApply</code>, <code>doFailure</code> or <code>doError</code> as soon as possible.</p>
</li>
<li>
<p>Data policies should interact with the data stream as efficiently as possible and prefer mutating in-place (especially with small changes).</p>
</li>
<li>
<p>If you are contributing a policy to apiman: implement any long-running tasks asynchronously (e.g. database calls); <strong>do not</strong> block the main thread (e.g. blocking futures, wait, sleep); use asynchronous techniques to interact with the outside world, such as callbacks.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_dependencies"><a class="anchor" href="#_dependencies"></a>Dependencies</h5>
<div class="paragraph">
<p>Typically a policy implementation should minimize the number of third party libraries
it depends on, but often times this is unavoidable.  Plugins are isolated from one
another, so it is a simple matter of including any required dependencies inside the
plugin&#8217;s WAR archive in the standard location of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>WEB-INF/lib</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You should make sure that any apiman dependencies you use (for example the apiman
core module that contains the IPlugin and other necessary interfaces) are marked
as 'provided' in your maven project so that they are not included in the plugin
archive.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_logging"><a class="anchor" href="#_logging"></a>Logging</h4>
<div class="paragraph">
<p>A policy&#8217;s logger can be accessed through the context objects provided to <code>apply</code>.
Use <code>getLogger</code> with a class. The <code>IApimanLogger</code> interface provides the methods
available for logging, with a variety of pluggable backends available to implement
the functionality.</p>
</div>
<div class="sect4">
<h5 id="_usage"><a class="anchor" href="#_usage"></a>Usage</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">  @Override
  public void apply(final ApiRequest request, final IPolicyContext context, final Object config,
          final IPolicyChain&lt;ApiRequest&gt; chain) {
      IApimanLogger logger = context.getLogger(getClass());
      logger.info("Hello, I am an info message in the request"); <i class="conum" data-value="1"></i><b>(1)</b>
      logger.debug("Hello, I am a debug message in the request");
      logger.trace("I am powered by: %s", request.getHeaders().get("X-Powered-By"));
      chain.doApply(request);
  }

  @Override
  public void apply(ApiResponse response, IPolicyContext context, Object config,
          IPolicyChain&lt;ApiResponse&gt; chain) {
      IApimanLogger logger = context.getLogger(getClass());
      logger.info("Response info message: %d", 42); <i class="conum" data-value="2"></i><b>(2)</b>
      chain.doApply(response);
  }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Consult the interface&#8217;s javadoc for the full list of available methods.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Format string with arguments.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_configuration"><a class="anchor" href="#_configuration"></a>Configuration</h5>
<div class="paragraph">
<p>A few logging backends <a href="https://github.com/apiman/apiman/tree/master/common/logging">are provided</a>,
which should satisfy most user&#8217;s requirements.</p>
</div>
<div class="paragraph">
<p>In <code>apiman.properties</code>, provide a reference to the logger factory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">apiman-gateway.logger-factory=io.apiman.common.logging.slf4j.Slf4jLoggerFactory</code></pre>
</div>
</div>
<div class="paragraph">
<p>Those shipped in the project, are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SLF4J: <code>io.apiman.common.logging.slf4j.Slf4jLoggerFactory</code></p>
</li>
<li>
<p>Log4j2: <code>io.apiman.common.logging.log4j2.Log4j2LoggerFactory</code></p>
</li>
<li>
<p>NoOp/Null: <code>io.apiman.common.logging.impl.NoOpLoggerFactory</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Ensure that the implementation is available on the classpath.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_custom_implementation"><a class="anchor" href="#_custom_implementation"></a>Custom Implementation</h5>
<div class="paragraph">
<p>To provide your own implementation, you must implement <code>IDelegateFactory</code> and which
should create instances your implementations of <code>IApimanLogger</code>. Ensure that your
implementations are available on the classpath, and refer to <a href="#_configuration">Configuration</a> to
set the <code>logger-factory</code> to your <code>IDelegateFactory</code>,which will cause the registry to
load your factory.</p>
</div>
<div class="paragraph">
<p>Example IDelegateFactory implementation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ExampleLoggerFactory implements IDelegateFactory {

    public ExampleLoggerFactory() {}
    public ExampleLoggerFactory(Map&lt;String, String&gt; opts) {} <i class="conum" data-value="1"></i><b>(1)</b>

    @Override
    public IApimanLogger createLogger(String name) {
        return new ExampleLogger(MyLoggerFactory.getLogger(name)); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    @Override
    public IApimanLogger createLogger(Class&lt;?&gt; klazz) {
      return new ExampleLogger(MyLoggerFactory.getLogger(klazz)); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If you pass config options from <code>apiman.properties</code> to your factory, they will appear here.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>MyLogger</code> is an example of the logger you&#8217;re wrapping.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>By class rather than string.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Example IApimanLogger implementation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ExampleLogger implements IDelegateFactory {
  MyLogger logger;

  public TestLogger() {}
  public TestLogger(MyLogger logger) {
    this.config = config;
  }

  public void info(String message) {
    logger.message(message); <i class="conum" data-value="1"></i><b>(1)</b>
  }

  // And many more... <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Passing the message through to your logger.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Debug, trace, etc. Consult the interface.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_provided_components"><a class="anchor" href="#_provided_components"></a>Provided Components</h5>
<div class="paragraph">
<p>All policy implementations have access to various resources at runtime.  These resources
are primarily accessed through the <strong>IPolicyContext</strong> object that is passed to the policy
when it is executed.  Along with the ability to set conversation-level attributes, the
policy context is how you access Policy Components.</p>
</div>
<div class="paragraph">
<p>A Policy Component is simply a runtime component that a policy implementation may find
useful.  To access a component, use the 'getComponent' method found on the policy
context, passing it the interface of the component you wish to use.  The following
components are available:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 71.4286%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPolicyFailureFactoryComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used to create a policy failure that is needed to call 'doFailure' on the policy chain (indicating that the policy failed).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ISharedStateComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used to share state information across the conversation boundary.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IHttpClientComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows HTTP requests to be made from within a policy.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IRateLimiterComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supports standard quota/rate limiting behavior, maintaining the current number of requests.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ILdapComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides the ability to authenticate with an LDAP server and execute simple queries against it.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IJdbcComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables querying of JDBC-capable datasources.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All the components have asynchronous APIs in order to better support the runtime
philosophy in the API Gateway.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For more information about each component, see its javadoc.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_policy_definition"><a class="anchor" href="#_policy_definition"></a>Policy Definition</h4>
<div class="paragraph">
<p>The policy implementation is what allows the API Gateway to execute the policy at runtime.
But how does the API Manager know about the policy so that users can add it to a Plan,
API, or Client App from within the User Interface?  The answer is that the plugin
must also include a Policy Definition JSON file for each policy it is providing.</p>
</div>
<div class="paragraph">
<p>A plugin definition is a JSON file that must be located within the plugin archive
here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>META-INF/apiman/policyDefs</code></pre>
</div>
</div>
<div class="paragraph">
<p>The plugin definition file takes the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "id" : "policy_name",
  "name" : "Policy Name",
  "description" : "A useful description of what the policy does.",
  "policyImpl" : "plugin:${project.groupId}:${project.artifactId}:${project.version}:${project.packaging}/com.example.plugins.MyFirstPolicy",
  "icon" : "document",
  "formType" : "JsonSchema",
  "form" : "schemas/policy_name.schema"
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>id</strong>: The unique id of the policy.</p>
</li>
<li>
<p><strong>name</strong>: The name of the policy.</p>
</li>
<li>
<p><strong>description</strong>: The description of the policy.</p>
</li>
<li>
<p><strong>policyImpl</strong>: Identifies the java class that implements the policy.</p>
</li>
<li>
<p><strong>icon</strong>: The icon to use when displaying the policy in the UI (name of a Font Awesome icon).</p>
</li>
<li>
<p><strong>formType</strong>: The type of form to use in the UI when configuring an instance of the policy.  See the Policy Configuration section below for details.  Valid values: <em>Default</em>, <em>JsonSchema</em></p>
</li>
<li>
<p><strong>form</strong>: (<em>optional</em>) Path to a UI form that should be used when configuring an instance of the policy.  See the Policy Configuration section below for details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The most important thing to get right in this file is probably the <code>policyImpl</code>.  This
is the information that the API Manager will use when it tries to instantiate the
policy implementation at runtime.  For policies that come from plugins, the format
of the <code>policyImpl</code> is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>plugin:{pluginGroupId}:{pluginArtifactId}:{pluginVersion}:{pluginType}/{fullyQualifiedClassname}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example of what this string might look like if you cracked open a valid apiman plugin
and had a peek at one of its policy definition files is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>plugin:io.apiman.plugins:apiman-plugins-example:6.3.3.Final:war/io.apiman.plugins.example.ExamplePolicy</code></pre>
</div>
</div>
<div class="paragraph">
<p>When building your plugin using the recommended maven configuration documented in the
<strong>Using Maven to Create a Plugin</strong> section, it is extremely convenient to simply let
Maven set the values for you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>plugin:${project.groupId}:${project.artifactId}:${project.version}:${project.packaging}/com.example.plugins.ExamplePolicy</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_policy_configuration_form"><a class="anchor" href="#_policy_configuration_form"></a>Policy Configuration Form</h4>
<div class="paragraph">
<p>You may be wondering how configuration information specific to a Plan, API, or
Client App is managed.  Since the same policy implementation instance is used for all
requests, unique configuration appropriate to a particular request must be passed to
the policy implementation when it is executed.  This configuration is created in the
API Manager user interface when adding the policy to a Plan, API, or Client App.</p>
</div>
<div class="paragraph">
<p>Policy configuration takes the form of string data that is ultimately included when
publishing an API to the API Gateway.  That string data is parsed into a Java object
via the 'parseConfiguration' on the <strong>IPolicy</strong> interface and then passed to the policy
during execution.</p>
</div>
<div class="paragraph">
<p>The string data is created in the API Manager user interface, either by interacting with
a Policy Configuration Form contributed by the plugin, or (if no form is included
in the plugin) by a default configuration form (a simple text area).</p>
</div>
<div class="sect4">
<h5 id="_default_policy_configuration"><a class="anchor" href="#_default_policy_configuration"></a>Default Policy Configuration</h5>
<div class="paragraph">
<p>If the policy definition indicates that the configuration form type is <strong>Default</strong>, then it is
up to the UI to determine how to display configuration information.  For the policies provided
by apiman itself, there are UI forms provided.  If the policy is contributed from a plugin,
then the UI has no way to know the format of the configuration data.  In this case, a simple
TextArea is presented to the user.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
This approach is clearly not recommended, because users will likely have no idea what to
enter into the TextArea presented to them.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_json_schema_policy_configuration"><a class="anchor" href="#_json_schema_policy_configuration"></a>JSON Schema Policy Configuration</h5>
<div class="paragraph">
<p>Alternatively, the policy definition can specify a <a href="http://json-schema.org/">JSON Schema</a> in
the policy definition JSON file.  For example, the policy definition might include the
following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">  "formType" : "JsonSchema",
  "form" : "schemas/policy_name.schema"</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, apiman will look for a file inside the plugin artifact in the following location:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>META-INF/apiman/policyDefs/schemas/policy_name.schema</code></pre>
</div>
</div>
<div class="paragraph">
<p>The file in this location must be a JSON Schema file, which describes the JSON format of the
configuration data expected by the policy implementation.  The UI will use this JSON schema
to generate an appropriate UI form that can edit the JSON configuration data needed by the
policy implementation.</p>
</div>
<div class="paragraph">
<p>Perhaps it&#8217;s best if we have an example.  The following illustrates a policy contributed from
a plugin, its JSON Schema file, the resulting form displayed in the UI, and the configuration
data format that will be passed to the policy implementation at runtime.</p>
</div>
<div class="listingblock">
<div class="title">META-INF/apiman/policyDefs/my-policy.json</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "id" : "my-policy",
  "name" : "My First Policy",
  "description" : "A policy with custom configuration!",
  "policyImpl" : "plugin:${project.groupId}:${project.artifactId}:${project.version}:${project.packaging}/io.apiman.plugins.config_policy.ConfigPolicy",
  "icon" : "pie-chart",
  "formType" : "JsonSchema",
  "templates" : [
    {
      "language": null,
      "template": "Set policy with @{property1} and @{property2}!"
    }
  ],
  "form" : "schemas/config-policyDef.schema"
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The templates 'language' field will support other languages in future, but
for now is null (i.e. single-language only). The template field itself is
<a href="https://github.com/mvel/mvel">MVEL</a> (Orb tag syntax), and displays in the UI
after a plugin has been selected by a user.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">META-INF/apiman/policyDefs/schemas/my-policy.schema</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "title" : "Configure My Policy",
  "description" : "Configure all of the necessary properties used by my policy.",
  "type" : "object",
  "properties": {
    "property1": {
      "title" : "Property 1",
      "type" : "string",
      "minLength" : 1,
      "maxLength" : 64
      },
    "property2": {
      "title" : "Property 2",
      "type" : "string",
      "minLength" : 1,
      "maxLength" : 64
    }
  }
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/plugin-policy-config-1.png" alt="Generated UI Form">
</div>
<div class="title">Figure 1. Generated UI Form</div>
</div>
<div class="listingblock">
<div class="title">JSON Configuration Data Format</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "property1" : "USER_DATA_1",
  "property2" : "USER_DATA_2"
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can easily consume the JSON configuration data above in your policy implementation
by having your policy implementation Java class extend the <code>AbstractMappedPolicy</code> base class
provided by apiman (in the <em>apiman-gateway-engine-policies</em> module) and creating a simple Java Bean
to hold the JSON configuration data.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>First, here is the java bean used to (un)marshal the JSON configuration data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyConfigBean implements Serializable {

  private static final long serialVersionUID = 683486516910591477L;

  private String property1;
  private String property2;

  /**
   * Constructor.
   */
  public MyConfigBean() {
  }

  public String getProperty1() {
    return property1;
  }

  public void setProperty1(String property1) {
    this.property1 = property1;
  }

  public String getProperty2() {
    return property2;
  }

  public void setProperty2(String property2) {
    this.property2 = property2;
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now have a look at how to use that class when extending the <code>AbstractMappedPolicy</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyPolicy extends AbstractMappedPolicy&lt;MyConfigBean&gt; {

  /**
   * Constructor.
   */
  public MyPolicy() {
  }

  @Override
  protected Class&lt;MyConfigBean&gt; getConfigurationClass() {
    return MyConfigBean.class;
  }

  @Override
  protected void doApply(ApiRequest request, IPolicyContext context, MyConfigBean config, IPolicyChain&lt;ApiRequest&gt; chain) {
    // Do something with MyConfigBean here?  It has all the configuration data!
    super.doApply(request, context, My, chain);
  }

  @Override
  protected void doApply(ApiResponse response, IPolicyContext context, MyConfigBean config, IPolicyChain&lt;ApiResponse&gt; chain) {
    // Do something with MyConfigBean here?  It has all the configuration data!
    super.doApply(response, context, config, chain);
  }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_json_schema_policy_configuration_sdk"><a class="anchor" href="#_json_schema_policy_configuration_sdk"></a>JSON Schema Policy Configuration SDK</h5>
<div class="paragraph">
<p>If you are creating a non-trivial JSON Schema (more than just a couple of simple fields)
it can be difficult to get it right without a few iterations.  For this reason, we have
created a simple "SDK" to help you create your JSON Schema quickly.  The SDK can be found
in the apiman github repository at the following location:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>manager/ui/war/src/main/sdk/json-schema.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have the apiman source code checked out, you can simply open that file in your browser
and start using it to author a custom JSON Schema.</p>
</div>
<div class="paragraph">
<p>Alternatively you can use "rawgit" and just go straight to the following URL:</p>
</div>
<div class="paragraph">
<p><a href="https://rawgit.com/apiman/apiman/master/manager/ui/war/src/main/sdk/json-schema.html" class="bare">https://rawgit.com/apiman/apiman/master/manager/ui/war/src/main/sdk/json-schema.html</a></p>
</div>
<div class="paragraph">
<p>The SDK provides a way to edit your JSON schema and then see how that schema will look in
the apiman UI, as well as the format that the policy configuration data will ultimately
be in when it is sent to your policy at runtime.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Once you have the JSON Schema finalized, you could also use the online <a href="http://www.jsonschema2pojo.org/">jsonschema2pojo</a>
tool to generate a good starting point for a Java Bean that can be used to marshal/unmarshal your policy&#8217;s configuration
data at runtime.  See the discussion about AbstractMappedPolicy above for additional information.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_unit_testing_a_plugin_policy"><a class="anchor" href="#_unit_testing_a_plugin_policy"></a>Unit Testing a Plugin Policy</h3>
<div class="paragraph">
<p>While it is quite simple to create a custom policy for apiman, you may be wondering the best way to
unit test your implementation.  Fortunately we have made this extremely easy by including an easy-to-use
Policy Testing junit framework.  Once you have followed the instructions above to create your custom
policy, refer to this section to learn how to test it using junit.</p>
</div>
<div class="sect3">
<h4 id="_import_the_framework_maven_dependency"><a class="anchor" href="#_import_the_framework_maven_dependency"></a>Import the Framework (Maven Dependency)</h4>
<div class="paragraph">
<p>The first thing you will need is to include the appropriate maven dependencies in your project&#8217;s
pom.xml file.  There is a single additional dependency that you will need (make sure to import it using
the 'test' maven scope):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
   &lt;groupId&gt;io.apiman&lt;/groupId&gt;
   &lt;artifactId&gt;apiman-test-policies&lt;/artifactId&gt;
   &lt;version&gt;1.1.2-SNAPSHOT&lt;/version&gt;
   &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_create_and_annotate_a_junit_test_case"><a class="anchor" href="#_create_and_annotate_a_junit_test_case"></a>Create and Annotate a JUnit Test Case</h4>
<div class="paragraph">
<p>Once you have imported the appropriate dependency, you can go ahead and create a JUnit test case.  The
only additional thing you need is to annotate your test case appropriately and make sure your test case
Java class extends the framework&#8217;s 'ApimanPolicyTest' base class.</p>
</div>
<div class="paragraph">
<p>The following annotations can then be added to your test:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@TestingPolicy(&lt;classname&gt;) - indicates which of your policy implementations you wish to test</p>
</li>
<li>
<p>@Configuration("&lt;custom_policy_configuration_data&gt;") - specifies the policy configuration to use for the test</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The @TestingPolicy annotation is always placed at the class level, but the @Configuration annotation can
either be global or specified at the test method level.</p>
</div>
<div class="paragraph">
<p>These annotations tell the apiman Policy Testing framework <strong>what</strong> policy you want to test and the
policy configuration you want to use when testsing, but you still need to actually send requests to a
"API".  This is done using the "send(PolicyTestReqest)" method defined by the base class.  The
send() method allows you to send a request (that you build) to the mock back-end API governed by
your policy.  By default the mock back-end API is a simple "echo" API that responds to all
requests with a JSON payload describing the request it received (more on how to override this default
functionality later).</p>
</div>
<div class="paragraph">
<p>The send() method requires that you create and pass to it a valid PolicyTestRequest object.  This can
be created using the PolicyTestRequest.build() method.  You can set the request&#8217;s type, resource path,
request headers, and body.  If the request is successful, then a PolicyTestResponse object will be
returned and you can perform assertions on it.  If there is a policy failure, then the send() method
will throw a PolicyFailureError.</p>
</div>
<div class="paragraph">
<p>Here is a full example of everything working together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestingPolicy(CustomPolicy.class)
public class CustomPolicyTest extends ApimanPolicyTest {

    @Test
    @Configuration("{}")
    public void testGet() throws Throwable {
        // Send a test HTTP request to the API (resulting in executing the policy).
        PolicyTestResponse response = send(PolicyTestRequest.build(PolicyTestRequestType.GET, "/some/resource")
                .header("X-Test-Name", "testGet"));

        // Now do some assertions on the result!
        Assert.assertEquals(200, response.code());
        EchoResponse entity = response.entity(EchoResponse.class);
        Assert.assertEquals("GET", entity.getMethod());
        Assert.assertEquals("/some/resource", entity.getResource());
        Assert.assertEquals("testGet", entity.getHeaders().get("X-Test-Name"));
        // Assert the request header that was added by the policy
        Assert.assertEquals("Hello World", entity.getHeaders().get("X-MTP-Header"));
        // Assert the response header was added by the policy
        Assert.assertEquals("Goodbye World", response.header("X-MTP-Response-Header"));
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_providing_a_custom_back_end_api_mock"><a class="anchor" href="#_providing_a_custom_back_end_api_mock"></a>Providing a Custom Back-End API Mock</h4>
<div class="paragraph">
<p>Sometimes the echo API is not sufficient when testing your custom policy.  Perhaps the custom policy
is more tightly coupled to the API it is protecting.  In this case you may want to provide your own
custom back-end API mock implementation.  This can be done by simply annotating either the class or
an individual test method with @BackEndApi.  If you do this then you must supply the annotation with
a class that implements the IPolicyTestBackEndApi interface.  Here is an example of what this might
look like in a test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TestingPolicy(CustomPolicy.class)
public class CustomPolicyTest extends ApimanPolicyTest {

    @Test
    @Configuration("{}")
    @BackEndApi(MyCustomBackEndApiImpl.class)
    public void testGetWithCustomBackEndSvc() throws Throwable {
        // Send a test HTTP request to the API (resulting in executing the policy).
        PolicyTestResponse response = send(PolicyTestRequest.build(PolicyTestRequestType.GET, "/some/resource")
                .header("X-Test-Name", "testGet"));

        // Now do some assertions on the result!
        MyCustomBackEndApiResponseBean entity = response.entity(MyCustomBackEndApiResponseBean.class);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example everything works as it did before, but instead of responding with an Echo Response
the send() method will return with a custom response (as created and returned by the provided custom
back-end API implementation).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_a_plugin_policy"><a class="anchor" href="#_using_a_plugin_policy"></a>Using a Plugin Policy</h3>
<div class="paragraph">
<p>Once you have built and unit tested your plugin policy, you will most likely want to actually use the policy
in apiman.  This can be done by adding the plugin to apiman via the Plugin Management UI in the API Manager
user interface.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Plugin Management UI is restricted to admin users of the API Manager.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more information about how to use the Plugin Management UI, please see the apiman User Guide.</p>
</div>
<div class="sect3">
<h4 id="_iterating_a_plugin_policy"><a class="anchor" href="#_iterating_a_plugin_policy"></a>Iterating a Plugin Policy</h4>
<div class="paragraph">
<p>When developing a custom plugin policy, it can be cumbersome to have to uninstall and reinstall the plugin
every time you make a change.  Hopefully, unit testing will help you quickly iterate your plugin policy
implementation, but there are times when testing in a live environment is necessary.</p>
</div>
<div class="paragraph">
<p>At runtime, the API Gateway installs plugins from the local <code>.m2</code> directory.  If the plugin is not found
there, only then will apiman attempt to find and download the plugin from the configured remote maven
repositories.  Typically, the API Gateway will load and cache the plugin the first time it is used.  However,
if your plugin <strong>version</strong> ends with "-SNAPSHOT", then apiman will reload it every time it is used.</p>
</div>
<div class="paragraph">
<p>As a result, you can quickly iterate changes to your plugin policy using a live apiman environment by doing
the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Ensure that you are testing a "-SNAPSHOT" version of your custom plugin policy</p>
</li>
<li>
<p>Configure the policy on one or more API</p>
</li>
<li>
<p>Publish the API(s) to the API Gateway</p>
</li>
<li>
<p>Send an HTTP request to an API that uses your custom policy</p>
</li>
<li>
<p>Make a change to your Policy implementation</p>
</li>
<li>
<p>Rebuild your plugin and "install" it into your .m2 directory (do not change the version)</p>
</li>
<li>
<p>Repeat starting at #4</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Because the version of your plugin ends with "-SNAPSHOT", the API Gateway will not cache it, but instead
will reload it each time you do step #4.  This allows you to quickly make changes, rebuild, and re-test
with a minimum of additional steps.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As of version 1.2.4.Final, you must explicitly enable this "auto plugin reloading" feature by setting
the following <strong>apiman.properties</strong> property to "true":  <code>apiman-gateway.policy-factory.reload-snapshots</code>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Don&#8217;t use this "auto plugin reloading" feature in production as the lack of policy caching will be a
significant performance problem.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_uninstalling_a_plugin"><a class="anchor" href="#_uninstalling_a_plugin"></a>Uninstalling a Plugin</h4>
<div class="paragraph">
<p>Again, you can use the Plugin Management UI to uninstall a plugin.  Please note that when you do this,
any API that is already configured to <strong>use</strong> the plugin will continue to work.  If you wish for an API
to no longer use a plugin policy, you must remove the policy from the API as a separate step.</p>
</div>
</div>
<div class="sect3">
<h4 id="_upgrading_a_plugin"><a class="anchor" href="#_upgrading_a_plugin"></a>Upgrading a Plugin</h4>
<div class="paragraph">
<p>Often times new versions of a plugin may become available.  When this happens you can use the Plugin
Management UI to upgrade a plugin to a newer version.  Please note that this will <strong>not</strong> automatically
upgrade any API using the older version of the plugin.  Instead, to upgrade an API to use the newer
plugin policy, you will need to remove the old policy configuration and re-add it.  This will cause
the API to pick up the newer version.  Of course, any <strong>new</strong> APIs will always use the new version.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_contributing_a_core_component"><a class="anchor" href="#_contributing_a_core_component"></a>Contributing a Core Component</h3>
<div class="paragraph">
<p>In addition to policies, the apiman plugin framework allows developers to provide custom implementations
of core apiman components.  What does this mean?  Apiman is composed of a number of different core
components, all working together to provide API Management functionality.  Both the API Gateway and
the API Manager have core components that can be customized by providing new implementations via plugins.</p>
</div>
<div class="paragraph">
<p>Some examples of API Manager components include (but are not limited to):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Storage Component</p>
</li>
<li>
<p>Query Component</p>
</li>
<li>
<p>IDM Component</p>
</li>
<li>
<p>Metrics Accessor (consumes metrics data recorded by the API Gateway at runtime)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, some examples of API Gateway components include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Configuration Registry</p>
</li>
<li>
<p>Rate Limiting Component</p>
</li>
<li>
<p>Metrics Emitter (records metrics data for each request)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, the apiman quickstart uses default values for all of these, resulting in a stable, working
system with the following characteristics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Stores API Manager data in a JDBC database</p>
</li>
<li>
<p>Records and queries metrics data via Elasticsearch</p>
</li>
<li>
<p>Stores Gateway configuration information in Elasticsearch</p>
</li>
<li>
<p>Uses Elasticsearch to share rate limiting state across gateway nodes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, if you wish to provide a custom implementation of something, you can implement the appropriate
Java interface for the correct component, bundle the implementation up into a plugin, and then tell
apiman to use yours instead of the default.</p>
</div>
<div class="sect3">
<h4 id="_implementing_a_custom_core_component"><a class="anchor" href="#_implementing_a_custom_core_component"></a>Implementing a Custom Core Component</h4>
<div class="paragraph">
<p>The procedure for creating a plugin to hold your custom component is exactly the same as already
described in the <strong>Creating a Plugin</strong> section above.  Once you have created your plugin, including
a custom implementation of a core component is simply a matter of creating a Java class that
implements the appropriate component interface.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s try an example.</p>
</div>
<div class="paragraph">
<p>By default, apiman stores API Gateway configuration in Elasticsearch.  The component responsible
for this is called ESRegistry, and it implements this interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.apiman.gateway.engine;

public interface IRegistry {

    public void getContract(ApiRequest request, IAsyncResultHandler&lt;ApiContract&gt; handler);

    public void publishApi(Api api, IAsyncResultHandler&lt;Void&gt; handler);

    public void retireApi(Api api, IAsyncResultHandler&lt;Void&gt; handler);

    public void registerClient(Client client, IAsyncResultHandler&lt;Void&gt; handler);

    public void unregisterClient(Client client, IAsyncResultHandler&lt;Void&gt; handler);

    public void getApi(String organizationId, String apiId, String apiVersion, IAsyncResultHandler&lt;Api&gt; handler);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perhaps you&#8217;d rather store the API Gateway configuration information into mongodb instead of
Elasticsearch.  Since we don&#8217;t support a mongodb registry, you would need to implement your own
and contribute it via a plugin.  Simple create a new plugin and include in it the following
Java class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.example.apiman.plugins;

public class MongoDbRegistry implements IRegistry {

    public MongoDbRegistry(Map&lt;String, String&gt; config) {
        // TODO consume any config params - these come from apiman.properties
    }

    public void getContract(ApiRequest request, IAsyncResultHandler&lt;ApiContract&gt; handler) {
        // TODO implement mongodb specific logic here
    }

    public void publishApi(Api api, IAsyncResultHandler&lt;Void&gt; handler) {
        // TODO implement mongodb specific logic here
    }

    public void retireApi(Api api, IAsyncResultHandler&lt;Void&gt; handler) {
        // TODO implement mongodb specific logic here
    }

    public void registerClient(Client client, IAsyncResultHandler&lt;Void&gt; handler) {
        // TODO implement mongodb specific logic here
    }

    public void unregisterClient(Client client, IAsyncResultHandler&lt;Void&gt; handler) {
        // TODO implement mongodb specific logic here
    }

    public void getApi(String organizationId, String apiId, String apiVersion, IAsyncResultHandler&lt;Api&gt; handler) {
        // TODO implement mongodb specific logic here
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
While optional, it is often useful to provide a constructor that takes a map of configuration
params.  These values comes from the <strong>apiman.properties</strong> and is an arbitrary set of keys/values.  It
can be extremely helpful when, for example, configuring the mongodb connection information.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_enabling_your_custom_component"><a class="anchor" href="#_enabling_your_custom_component"></a>Enabling Your Custom Component</h4>
<div class="paragraph">
<p>Now that you have a custom component built and included in a plugin, you will need to make sure
that the plugin is available to your server.  You can do this by deploying the plugin artifact
to a maven repository and then making that repository available to apiman by adding its URL to
the following property in <strong>apiman.properties</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman.plugins.repositories=http://repository.jboss.org/nexus/content/groups/public/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simply add your organization&#8217;s maven repository to that (the value can be a comma separated list of
URLs).</p>
</div>
<div class="paragraph">
<p>Alternatively, you can make sure your plugin is installed in the ".m2" directory on the machine
that is running your server.  Obviously you can use "mvn install" to accomplish this.</p>
</div>
<div class="paragraph">
<p>Next, simply enable the custom component implementation by updating your <strong>apiman.properties</strong> file
like this (for example):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.registry=plugin:GROUP_ID:ARTIFACT_ID:VERSION/org.example.apiman.plugins.MongoDbRegistry
apiman-gateway.registry.mongo.host=localhost
apiman-gateway.registry.mongo.port=27017
apiman-gateway.registry.mongo.username=sa
apiman-gateway.registry.mongo.password=sa123!
apiman-gateway.registry.mongo.database=apiman</code></pre>
</div>
</div>
<div class="paragraph">
<p>The most important part above is the format for the registry itself.  It might look something like
this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.registry=plugin:org.example.apiman-plugins:plugin-mongodb:1.0.0.Final/org.example.apiman.plugins.MongoDbRegistry</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the set of properties prefixed with "apiman-gateway.registry" will be processed and passed
to your <strong>MongoDbRegistry</strong> class&#8217;s <strong>Map</strong> constructor if one is provided.  The map that is passed to
the constructor will contain the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>mongo.host=localhost
mongo.port=27017
mongo.username=sa
mongo.password=sa123!
mongo.database=apiman</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_core_component_customization_points"><a class="anchor" href="#_core_component_customization_points"></a>Core Component Customization Points</h4>
<div class="paragraph">
<p>This section lists all/most of the available customization points available within apiman.  These represent
all of the core apiman components that can be replaced by custom implementations provided via plugins.</p>
</div>
<div class="sect4">
<h5 id="_api_manager_components"><a class="anchor" href="#_api_manager_components"></a>API Manager Components</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component Interface</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.manager.api.core.INewUserBootstrapper</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows customizing users upon first login (e.g. create an org for the user).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.manager.api.core.IStorage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primary storage of all API Manager data.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.manager.api.core.IStorageQuery</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows querying of the API Manager data.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.manager.api.core.IMetricsAccessor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used by the API Manager to query Metrics data collected by the API Gateway.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.manager.api.core.IApiKeyGenerator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used to create an API Key for each created API Contract.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.common.util.crypt.IDataEncrypter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used primarily by the storage layer to encrypt potentially sensitive data prior to storing it.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.manager.api.core.IApiCatalog</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides access to external APIs which users may wish to import.</p></td>
</tr>
</tbody>
</table>
<div class="sect5">
<h6 id="_io_apiman_manager_api_core_inewuserbootstrapper_example_configuration"><a class="anchor" href="#_io_apiman_manager_api_core_inewuserbootstrapper_example_configuration"></a>io.apiman.manager.api.core.INewUserBootstrapper Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-manager.user-bootstrapper.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooUserBootstrapperImpl
apiman-manager.user-bootstrapper.foo1=value-1
apiman-manager.user-bootstrapper.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_manager_api_core_istorage_example_configuration"><a class="anchor" href="#_io_apiman_manager_api_core_istorage_example_configuration"></a>io.apiman.manager.api.core.IStorage Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-manager.storage.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooStorageImpl
apiman-manager.storage.foo1=value-1
apiman-manager.storage.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_manager_api_core_istoragequery_example_configuration"><a class="anchor" href="#_io_apiman_manager_api_core_istoragequery_example_configuration"></a>io.apiman.manager.api.core.IStorageQuery Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-manager.storage-query.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooStorageQueryImpl
apiman-manager.storage-query.foo1=value-1
apiman-manager.storage-query.foo2=value-2</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If your custom IStorage implementation <strong>also</strong> implements IStorageQuery, then it will be used instead of
trying to create a separate instance of IStorageQuery.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_manager_api_core_imetricsaccessor_example_configuration"><a class="anchor" href="#_io_apiman_manager_api_core_imetricsaccessor_example_configuration"></a>io.apiman.manager.api.core.IMetricsAccessor Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-manager.metrics.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooMetricsAccessorImpl
apiman-manager.metrics.foo1=value-1
apiman-manager.metrics.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_manager_api_core_iapikeygenerator_example_configuration"><a class="anchor" href="#_io_apiman_manager_api_core_iapikeygenerator_example_configuration"></a>io.apiman.manager.api.core.IApiKeyGenerator Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-manager.api-keys.generator.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooApiKeyGeneratorImpl
apiman-manager.api-keys.generator.foo1=value-1
apiman-manager.api-keys.generator.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_common_util_crypt_idataencrypter_example_configuration"><a class="anchor" href="#_io_apiman_common_util_crypt_idataencrypter_example_configuration"></a>io.apiman.common.util.crypt.IDataEncrypter Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman.encrypter.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooDataEncrypter
apiman.encrypter.foo1=value-1
apiman.encrypter.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_manager_api_core_iapicatalog_example_configuration"><a class="anchor" href="#_io_apiman_manager_api_core_iapicatalog_example_configuration"></a>io.apiman.manager.api.core.IApiCatalog Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-manager.api-catalog.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooApiCatalogImpl
apiman-manager.api-catalog.foo1=value-1
apiman-manager.api-catalog.foo2=value-2</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_api_gateway_components"><a class="anchor" href="#_api_gateway_components"></a>API Gateway Components</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component Interface</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.IRegistry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stores gateway configuration data (e.g. published APIs).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.common.util.crypt.IDataEncrypter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used to encrypt potentially sensitive data prior to storing in the registry.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.IConnectorFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates connectors to back-end APIs based on API meta-information.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.policy.IPolicyFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loads policy implementations (from plugins or else internally).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.IPolicyFailureWriter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Writes a policy failure to the HTTP response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.IPolicyErrorWriter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Writes a policy error to the HTTP response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.components.IBufferFactoryComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates an ApimanBuffer (typically this is provided by the platform support).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.components.ICacheStoreComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows storing data into a cache store.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.components.IHttpClientComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates HTTP clients for use in policies.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.components.IJdbcComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Async component used to perform JDBC operations in policies.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.components.ILdapComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Async component used to perform LDAP operations in policies.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.components.IPeriodicComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates timers (for use by policies).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.components.IPolicyFailureFactoryComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creates policy failures (for use by policies).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.components.IRateLimiterComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Used by the rate limiting and quota policies.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.apiman.gateway.engine.components.ISharedStateComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">General purpose component to share state across policy invokations.</p></td>
</tr>
</tbody>
</table>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_iregistry_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_iregistry_example_configuration"></a>io.apiman.gateway.engine.IRegistry Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.registry=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooRegistryImpl
apiman-gateway.registry.foo1=value-1</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_common_util_crypt_idataencrypter_example_configuration_2"><a class="anchor" href="#_io_apiman_common_util_crypt_idataencrypter_example_configuration_2"></a>io.apiman.common.util.crypt.IDataEncrypter Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman.encrypter.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooDataEncrypter
apiman.encrypter.foo1=value-1
apiman.encrypter.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_iconnectorfactory_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_iconnectorfactory_example_configuration"></a>io.apiman.gateway.engine.IConnectorFactory Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.connector-factory=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooConnectorFactoryImpl
apiman-gateway.connector-factory.foo1=value-1
apiman-gateway.connector-factory.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_policy_ipolicyfactory_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_policy_ipolicyfactory_example_configuration"></a>io.apiman.gateway.engine.policy.IPolicyFactory Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.policy-factory=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooPolicyFactoryImpl
apiman-gateway.policy-factory.foo1=value-1
apiman-gateway.policy-factory.foo2=value-2</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Note</strong>: there is rarely a reason to provide a custom policy factory.</p>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_ipolicyfailurewriter_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_ipolicyfailurewriter_example_configuration"></a>io.apiman.gateway.engine.IPolicyFailureWriter Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.writers.policy-failure=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooPolicyFailureWriterImpl
apiman-gateway.writers.policy-failure.foo1=value-1
apiman-gateway.writers.policy-failure.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_ipolicyerrorwriter_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_ipolicyerrorwriter_example_configuration"></a>io.apiman.gateway.engine.IPolicyErrorWriter Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.writers.error=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooPolicyErrorWriterImpl
apiman-gateway.writers.error.foo1=value-1
apiman-gateway.writers.error.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_components_ibufferfactorycomponent_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_components_ibufferfactorycomponent_example_configuration"></a>io.apiman.gateway.engine.components.IBufferFactoryComponent Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.components.IBufferFactoryComponent=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooBufferFactoryComponentImpl
apiman-gateway.components.IBufferFactoryComponent.foo1=value-1
apiman-gateway.components.IBufferFactoryComponent.foo2=value-2</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Note</strong>: typically the buffer factory is specific to the platform.  For example, there is a buffer factory
used when the API Gateway is running in EAP or WildFly.  There is a different buffer factory used when the
API Gateway is running in vert.x.  There is typically not another reason to override this.</p>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_components_icachestorecomponent_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_components_icachestorecomponent_example_configuration"></a>io.apiman.gateway.engine.components.ICacheStoreComponent Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.components.ICacheStoreComponent=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooCacheStoreComponentImpl
apiman-gateway.components.ICacheStoreComponent.foo1=value-1
apiman-gateway.components.ICacheStoreComponent.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_components_ihttpclientcomponent_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_components_ihttpclientcomponent_example_configuration"></a>io.apiman.gateway.engine.components.IHttpClientComponent Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.components.IHttpClientComponent=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooHttpClientComponentImpl
apiman-gateway.components.IHttpClientComponent.foo1=value-1
apiman-gateway.components.IHttpClientComponent.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_components_ijdbccomponent_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_components_ijdbccomponent_example_configuration"></a>io.apiman.gateway.engine.components.IJdbcComponent Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.components.IJdbcComponent=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooJdbcComponentImpl
apiman-gateway.components.IJdbcComponent.foo1=value-1
apiman-gateway.components.IJdbcComponent.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_components_ildapcomponent_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_components_ildapcomponent_example_configuration"></a>io.apiman.gateway.engine.components.ILdapComponent Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.components.ILdapComponent=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooLdapComponentImpl
apiman-gateway.components.ILdapComponent.foo1=value-1
apiman-gateway.components.ILdapComponent.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_components_iperiodiccomponent_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_components_iperiodiccomponent_example_configuration"></a>io.apiman.gateway.engine.components.IPeriodicComponent Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.components.IPeriodicComponent=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooPeriodicComponentImpl
apiman-gateway.components.IPeriodicComponent.foo1=value-1
apiman-gateway.components.IPeriodicComponent.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_components_ipolicyfailurefactorycomponent_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_components_ipolicyfailurefactorycomponent_example_configuration"></a>io.apiman.gateway.engine.components.IPolicyFailureFactoryComponent Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.components.IPolicyFailureFactoryComponent=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooPolicyFailureFactoryComponentImpl
apiman-gateway.components.IPolicyFailureFactoryComponent.foo1=value-1
apiman-gateway.components.IPolicyFailureFactoryComponent.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_components_iratelimitercomponent_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_components_iratelimitercomponent_example_configuration"></a>io.apiman.gateway.engine.components.IRateLimiterComponent Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.components.IRateLimiterComponent=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooRateLimiterComponentImpl
apiman-gateway.components.IRateLimiterComponent.foo1=value-1
apiman-gateway.components.IRateLimiterComponent.foo2=value-2</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_io_apiman_gateway_engine_components_isharedstatecomponent_example_configuration"><a class="anchor" href="#_io_apiman_gateway_engine_components_isharedstatecomponent_example_configuration"></a>io.apiman.gateway.engine.components.ISharedStateComponent Example Configuration</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.components.ISharedStateComponent=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.FooSharedStateComponentImpl
apiman-gateway.components.ISharedStateComponent.foo1=value-1
apiman-gateway.components.ISharedStateComponent.foo2=value-2</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_providing_a_custom_api_catalog"><a class="anchor" href="#_providing_a_custom_api_catalog"></a>Providing a Custom API Catalog</h4>
<div class="paragraph">
<p>Apiman allows users to import one or more API (to be managed) from a globally configured API Catalog.  This
feature makes it easier to manage APIs that are "known" by providing API catalog entries which include
information such as the endpoint, endpoint type, etc.  Importing an API from the catalog brings those fields
into apiman, so that users don&#8217;t have to manually set them.</p>
</div>
<div class="paragraph">
<p>When installing apiman, a custom API Catalog can be easily configured by creating a propertly formatted JSON
file with all of the appropriate information included.  See the <strong>Installation Guide</strong> for more information
about configuring a JSON based custom API Catalog.</p>
</div>
<div class="paragraph">
<p>Additionally, it is possible to completely replace the API Catalog implementation, providing your own custom
version which retrieves API information from wherever you like.  Like most components, a custom API Catalog
implementation is simply a Java class which implements a specific interface and is enabled/configured in the
<em>apiman.properties</em> file.</p>
</div>
<div class="paragraph">
<p>The interface you must implement is <strong>io.apiman.manager.api.core.IApiCatalog</strong> and looked like this at the
time of this writing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Represents some sort of catalog of live APIs.  This is used to lookup
 * APIs to import into apiman.
 */
public interface IApiCatalog {

    /**
     * Called to find available APIs that match the given search keyword.  Note that
     * the search keyword may be a partial word (for example "ech" instead of "echo").  It
     * is up to the implementation to decide how to handle partial cases.  Typically this
     * should return all APIs that contain the partial keyword, thus returning things
     * like "echo" "public-echo" and "echo-location".
     *
     * @param keyword the search keyword
     * @return the available APIs
     */
    public List&lt;AvailableApiBean&gt; search(String keyword);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The catalog is simply one method which returns a list of <strong>AvailableApiBean</strong> objects.  That class
looks something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * A bean modeling an API available in one of the configured API catalogs.
 */
@JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)
public class AvailableApiBean implements Serializable {

    private String id;
    private String icon;
    private String endpoint;
    private EndpointType endpointType = EndpointType.rest;
    private String name;
    private String description;
    private String definitionUrl;
    private ApiDefinitionType definitionType;

    /**
     * Constructor.
     */
    public AvailableApiBean() {
    }

    /** SNIPPED ALL GETTERS/SETTERS **/
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create an implementation of this interface and include it in a valid apiman plugin.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See the "Creating a Plugin" section of this guide for more information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the plugin is created with your class inside, configure the catalog in <em>apiman.properties</em> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-manager.api-catalog.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.ApiCatalogImpl
apiman-manager.api-catalog.property1=value-1
apiman-manager.api-catalog.property2=value-2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember, if your implementation class has a constructor that accepts a Map&lt;String, String&gt;, then apiman
will pass the set of applicable configuration properties it finds in apiman.properties when the class is
instantiated.</p>
</div>
</div>
<div class="sect3">
<h4 id="_providing_a_custom_data_encrypter"><a class="anchor" href="#_providing_a_custom_data_encrypter"></a>Providing a Custom Data Encrypter</h4>
<div class="paragraph">
<p>Whenever apiman stores data, either in the API Manager or in the API Gateway, it uses a Data Encrypter
to first encrypt potentially sensitive information.  Examples are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Policy Configuration</p>
</li>
<li>
<p>Endpoint Properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, the apiman quickstart comes with a default encrypter that performs very simple synchronous
encryption on this data.  However, because it is built-in, it is not secure (it uses a hard-coded
encryption key, for example).  Depending on your security needs, you may wish to implement a custom
data encrypter - one that is more secure and perhaps uses externally configured keys.</p>
</div>
<div class="paragraph">
<p>In order to provide a custom data encrypter, the interface you must implement is
<strong>io.apiman.common.util.crypt.IDataEncrypter</strong>.  This same interface is used in both the API Manager and
the API Gateway.  The IDataEncrypter interface looks something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Provides a way to encrypt and decrypt data. This is useful when encrypting sensitive
 * data prior to storing it in the database.
 */
public interface IDataEncrypter {

    public String encrypt(String plainText);

    public String decrypt(String encryptedText);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When creating a custom implementation, all you need to do is provide a Java class which implements
the above interface inside a valid apiman plugin.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See the "Creating a Plugin" section of this guide for more information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the plugin is created with your class inside, configure the data encrypter in <em>apiman.properties</em> like
this (<strong>note</strong>: it only needs to be configured in a single place for both the Manager and Gateway):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman.encrypter.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.DataEncrypterImpl
apiman.encrypter.property1=value-1
apiman.encrypter.property2=value-2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember, if your implementation class has a constructor that accepts a Map&lt;String, String&gt;, then apiman
will pass the set of applicable configuration properties it finds in apiman.properties when the class is
instantiated.  In the example above, your DataEncrypterImpl class will be instantiated, with a Map
passed to its constructor containing the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>property1=value-1</p>
</li>
<li>
<p>property2=value-2</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_providing_a_custom_policy_failureerror_writer"><a class="anchor" href="#_providing_a_custom_policy_failureerror_writer"></a>Providing a Custom Policy Failure/Error Writer</h4>
<div class="paragraph">
<p>When a policy fails (or an error occurs) in the API Gateway, the result of the failure must be sent
back to the calling HTTP client.  By default, apiman has a particular format (either JSON or XML
depending on the Content-Type of the API being called) it uses when responding to the client.  However,
some installers may prefer a custom format for these.  This can be accomplished by providing a custom
implementation of <strong>io.apiman.gateway.engine.IPolicyFailureWriter</strong> and/or a custom implementation of
<strong>io.apiman.gateway.engine.IPolicyErrorWriter</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface IPolicyFailureWriter {

    public void write(ApiRequest request, PolicyFailure failure, IApiClientResponse response);

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface IPolicyErrorWriter {

    public void write(ApiRequest request, Throwable error, IApiClientResponse response);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When creating a custom implementation, all you need to do is provide a Java class which implements
the above interface(s) inside a valid apiman plugin.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See the "Creating a Plugin" section of this guide for more information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the plugin is created with your class inside, configure either the failure writer, the error
writer, or both in <em>apiman.properties</em> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.writers.policy-failure=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.PolicyFailureWriterImpl
apiman-gateway.writers.policy-failure.property1=value-1
apiman-gateway.writers.policy-failure.property2=value-2</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-gateway.writers.error=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.PolicyErrorWriterImpl
apiman-gateway.writers.error.property1=value-1
apiman-gateway.writers.error.property2=value-2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember, if your implementation class has a constructor that accepts a Map&lt;String, String&gt;, then apiman
will pass the set of applicable configuration properties it finds in apiman.properties when the class is
instantiated.  In the example above, your DataEncrypterImpl class will be instantiated, with a Map
passed to its constructor containing the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>property1=value-1</p>
</li>
<li>
<p>property2=value-2</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_providing_a_custom_user_bootstrapper"><a class="anchor" href="#_providing_a_custom_user_bootstrapper"></a>Providing a Custom User Bootstrapper</h4>
<div class="paragraph">
<p>Whenever a new user is added to apiman, a record is added for her in the API Manager data store.  No
additional steps are taken by default.  However, in some cases you may want to perform some specific
bootstrapping tasks when a new user is created, for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Grant specific roles to the user</p>
</li>
<li>
<p>Auto-create an Organization for the user</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This can be done by providing your own custom implementation of <strong>io.apiman.manager.api.core.INewUserBootstrapper</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * This class is used to bootstrap new users.  This bootstrapper is used
 * whenever a new user logs into the API Manager UI for the first time.
 */
public interface INewUserBootstrapper {

    /**
     * Called to bootstrap a user.
     */
    public void bootstrapUser(UserBean user, IStorage storage) throws StorageException;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When invoked, the boostrap method is given the <strong>UserBean</strong> of the user being created as well as the
storage object.  The storage object can be used to create additional entities for the user, such as
new organizations or new memberships in roles.</p>
</div>
<div class="paragraph">
<p>When creating a custom implementation, all you need to do is provide a Java class which implements
the above interface inside a valid apiman plugin.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See the "Creating a Plugin" section of this guide for more information.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once the plugin is created with your class inside, configure the user bootstrapper in in <em>apiman.properties</em>
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apiman-manager.user-bootstrapper.type=plugin:com.example.groupId:artifactId:1.0.Final/com.example.apiman.UserBootstrapperImpl
apiman-manager.user-bootstrapper.property1=value-1
apiman-manager.user-bootstrapper.property2=value-2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember, if your implementation class has a constructor that accepts a Map&lt;String, String&gt;, then apiman
will pass the set of applicable configuration properties it finds in apiman.properties when the class is
instantiated.  In the example above, your DataEncrypterImpl class will be instantiated, with a Map
passed to its constructor containing the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>property1=value-1</p>
</li>
<li>
<p>property2=value-2</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_gateway_implementations"><a class="anchor" href="#_gateway_implementations"></a>Gateway Implementations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At the heart of any apiman gateway implementation is the flexible, lightweight
apiman-core. The core serves to execute policies upon the traffic passing through
it, determining whether a given conversation should continue or not.</p>
</div>
<div class="paragraph">
<p>A set of simple, asynchronous interfaces are provided which an implementor should
fulfill using the platform&#8217;s native functionality to allow apiman to interact with
its various components and services.</p>
</div>
<div class="sect2">
<h3 id="_implementing_iapimanbuffer"><a class="anchor" href="#_implementing_iapimanbuffer"></a>Implementing IApimanBuffer</h3>
<div class="paragraph">
<p>Before you can send any data through apiman, you must implement the <code>IApimanBuffer</code> interface. It provides a set of methods which allow apiman to access your native buffer format as effectively as possible. Any data you pass into apiman must be wrapped in your implementation of <code>IApimanBuffer</code>, whilst any data returned to you by apiman will be an <code>IApimanBuffer</code> which you can extricate your native buffer from.</p>
</div>
<div class="paragraph">
<p>Implementation is fairy self explanatory, but a few points are worth noting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class YourApimanBufferImpl implements IApimanBuffer {

  private YourNativeBuffer nativeBuffer;

  public VertxApimanBuffer(YourNativeBuffer nativeBuffer) {
    this.nativeBuffer = nativeBuffer;
  }

  // This is your mechanism to efficiently yank your native buffer back
  @Override
  public Object getNativeBuffer() {
    return nativeBuffer;
  }

  @Override
  public int length() {
    return nativeBuffer.length();
  }

  @Override
  public void insert(int index, IApimanBuffer buffer) {
    nativeBuffer.setBuffer(index, (Buffer) buffer.getNativeBuffer());
  }

  &lt;...&gt;
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Implementors of <code>IApimanBuffer</code> should ensure that the native format is preserved within the instance, this allows it to be retrieved again using <code>getNativeBuffer</code>. Any mutation should be on the native buffer.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_executing_apiman_core"><a class="anchor" href="#_executing_apiman_core"></a>Executing apiman-core</h3>
<div class="paragraph">
<p>Let&#8217;s consider the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IEngine engine = new &lt;your engine&gt;.createEngine();

// Request executor, through which we can send chunks and indicate end.
final IApiRequestExecutor requestExecutor = engine.executor(request,
  new IAsyncResultHandler&lt;IEngineResult&gt;() {
    public void handle(IAsyncResult&lt;IEngineResult&gt; result) { ... }
  });

// streamHandler called when back-end connector is ready to receive data.
requestExecutor.streamHandler(new IAsyncHandler&lt;IApiConnection&gt;() {
  public void handle(final IApiConnection writeStream) { ... }
});

// Execute the request
executor.execute();</code></pre>
</div>
</div>
<div class="paragraph">
<p>After instantiating your engine implementation, you can call <code>execute</code>. This is the main point through which you pipe data into and out of apiman. In order to avoid any buffering you must write body data through <code>streamHandler&#8217;s `IApiConnection</code> which will be called when the connection to the backend API is ready to receive. The result is provided to <code>executor&#8217;s `IAsyncResultHandler</code>, which can be evaluated to determine the result of the call, and, if successful, retrieve a <code>ApiResponse</code> and attach handlers to receive response data.</p>
</div>
<div class="sect3">
<h4 id="_streaming_data"><a class="anchor" href="#_streaming_data"></a>Streaming data</h4>
<div class="paragraph">
<p>Exploring <code>streamHandler</code> further:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">requestExecutor.streamHandler(new IAsyncHandler&lt;IApiConnection&gt;() {

  @Override
  public void handle(final IApiConnection writeStream) {
    // Just for illustrative purposes
    IApimanBuffer apimanBuffer =
      new YourApimanBufferImpl(nativeBuffer);

    // Call #write as many times as desired.
    writeStream.write(apimanBuffer);

    // Call #end only once.
    writeStream.end();
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any data flowing into the executor must first be wrapped in your implementation of <code>IApimanBuffer</code> before being passed to <code>write</code>. You may call <code>write</code> an unlimited number of times, and indicate that transmission has completed by signalling <code>end</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
No further calls to <code>write</code> should occur after <code>end</code> has been called.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_handling_results"><a class="anchor" href="#_handling_results"></a>Handling results</h4>
<div class="paragraph">
<p>An excerpt of the executor&#8217;s result handler and considering a successful result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">engine.executor(request, new IAsyncResultHandler&lt;IEngineResult&gt;() {
  public void handle(IAsyncResult&lt;IEngineResult&gt; result) {
    // Did an exception occur?
    if (result.isSuccess()) {
      IEngineResult engineResult = result.getResult();

      if (engineResult.isResponse()) {
        // Our successfully returned API response.
        ApiResponse response = engineResult.getApiResponse();

        // Set a bodyHandler to receive the response's body chunks.
        engineResult.bodyHandler(new IAsyncHandler&lt;IApimanBuffer&gt;() {

          @Override
          public void handle(IApimanBuffer chunk) {
            // Important: for efficiency, retrieve native buffer format directly if possible.
            if(chunk.getNativeBuffer() instanceof YourNativeBuffer) {
              YourNativeBuffer buffer = (YourNativeBuffer) chunk.getNativeBuffer();
            }
          }
        });

        // Set an endHandler to receive the end signal.
        engineResult.endHandler(new IAsyncHandler&lt;Void&gt;() {

          @Override
          public void handle(Void flag) {
            // Transmission has now completed.
          }
        });

      } else {
        // Handle policy failure.
      }

    } else {
      // Handle exception.
    }
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>After testing <code>IAsyncResult.isSuccess</code>, we can be certain that the request completed without an exception occurring. Next, we verify <code>IEngineResult.isFailure</code>, which indicates whether there was a policy failure or the response returned successfully.</p>
</div>
<div class="paragraph">
<p>Upon success the <code>ApiResponse</code> can be extracted, and a <code>bodyHandler</code> and <code>endHandler</code> can be attached in order to receive the response&#8217;s associated data as it arrives. At this point the data has exited apiman, and can handled as makes sense for your implementation. For instance, you may wish to translate the <code>ApiResponse</code> into its native equivalent and return it to the requestor.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Where possible, it is advisable to use <code>getNativeBuffer</code> on any <code>IApimanBuffer</code> chunks you receive; avoiding any expensive format conversions. You must cast it back to your native format; <code>instanceof</code> is helpful to ensure the the correct type has been received.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_handling_failures"><a class="anchor" href="#_handling_failures"></a>Handling Failures</h4>
<div class="paragraph">
<p>In the case of errors or policy failures, a variety of information is provided which can be used to construct a sensible response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if (result.isSuccess()) {
  IEngineResult engineResult = result.getResult();

  if (!engineResult.isFailure()) {
    &lt;...&gt;
  } else {
    PolicyFailure policyFailure = engineResult.getPolicyFailure();
    log.info("Failure type: " + policyFailure.getType());
    log.info("Failure code: " + policyFailure.getFailureCode());
    log.info("Failure Message: " + policyFailure.getMessage());
    log.info("Failure Headers: " + policyFailure.getHeaders());
  }
} else {
  Throwable throwable = engineResult.getError();
  log.error("Something bad happened: " + throwable);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The appropriate response to failures will vary widely depending upon implementation. For instance, a RESTful platform may wish to transmit an appropriate HTTP error code, message and possibly body.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_an_api_connector"><a class="anchor" href="#_creating_an_api_connector"></a>Creating an API Connector</h3>
<div class="paragraph">
<p>Connectors enable apiman to transmit and receive data from the backend APIs under management. For instance, should your system need to connect to an HTTP API, an HTTP connector must be created. The following samples illustrate in general terms how an implementor may go about creating a connector, and although the specifics will vary extremely widely depending upon the platform some general principals should be obeyed.</p>
</div>
<div class="sect3">
<h4 id="_connector_basics"><a class="anchor" href="#_connector_basics"></a>Connector basics</h4>
<div class="paragraph">
<p>Inside of your <code>IConnectorFactory</code> implementation you must return an <code>IApiConnector</code> corresponding to the type of request and API being interacted with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ConnectorFactory implements IConnectorFactory {

  public IApiConnector createConnector(ApiRequest request, Api api) {
    return new IApiConnector() {
    	...
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inspecting the <code>IApiConnector</code> more closely, we can see the key interface of a connector:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public IApiConnection request(ApiRequest request,
  IAsyncResultHandler&lt;IApiConnectionResponse&gt; resultHandler) {
  		...
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>IApiConnection</code> you must return is used by apiman to write request chunks; hence, it will be <strong>read</strong> by your connector. Conversely, the <code>IApiConnectionResponse</code> handler must be called in order to send the <code>ApiResponse</code> and its associated data chunks back to apiman once a response has returned from the API; hence, you will <strong>write</strong> data to it.</p>
</div>
<div class="paragraph">
<p>The <code>IAsyncResultHandler</code> is also used to indicate whether an exception has occurred during the conversation with the backend.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_the_iapiconnection"><a class="anchor" href="#_creating_the_iapiconnection"></a>Creating the IApiConnection</h4>
<div class="paragraph">
<p>Generally, an implementor must attempt to return their <code>IApiConnection</code> as soon as it is valid for apiman to write data to the backend. Until you respond, apiman will not fire <code>IApiRequestExecutor.streamHandler</code>, and hence no data will arrive prematurely to your connector. Following this guideline should help to minimise or eliminate any buffering requirements in your connectors.</p>
</div>
<div class="paragraph">
<p>Looking at an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Native platform's connector (e.g. HTTP)
ImaginaryBackendConnector imaginaryConnector = ...;
Connection c = imaginaryConnector.establishConnection(api.getEndpoint(), ...);

// Prepare in advance to do something sensible with the response
// See next section for more detail.
c.responseHandler(&lt;Handle the response; return an IApiConnectionResponse&gt;);

// From our perspective IApiConnection is
// *inbound data* (i.e. the user writes to us).
return new IApiConnection() {
  boolean finished = false;

  @Override
  public void write(IApimanBuffer chunk) {
    // Handle arriving data chunk
    YourNativeBuffer nativeBuffer =
      (YourNativeBuffer) chunk.getNativeBuffer();

    imaginaryConnector.write(nativeBuffer);
  }

  @Override
  public void end() {
    // Handle the signal to indicate stream has completed
    imaginaryConnector.finish_connection();
    finished = true;
  }

  @Override
  public void abort() {
    // Handle immediate abort, for instance by closing your connection.
    imaginaryConnector.abort();
    finished = true;
  }


  @Override
  public boolean isFinished() {
    return finished;
  }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>imaginaryConnector</code> represents your platform&#8217;s backend connector. After establishing a connection that can accept data, you should return an <code>IApiConnection</code>, allowing data to be written to your connector. You can extract your native buffer format using <code>getNativeBuffer</code> plus a cast. Although we haven&#8217;t yet explored how to handle a response, we can imagine that the platform&#8217;s <code>ImaginaryBackendConnector</code> would allows us to set a <code>responseHandler</code>, which will be fired when a response has arrived; this is point at which we can build an <code>IApiConnectionResponse</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_the_iapiconnectionresponse"><a class="anchor" href="#_creating_the_iapiconnectionresponse"></a>Creating the IApiConnectionResponse</h4>
<div class="sect4">
<h5 id="_handling_a_successful_response"><a class="anchor" href="#_handling_a_successful_response"></a>Handling a successful response</h5>
<div class="paragraph">
<p>Apiman&#8217;s <code>resultHandler</code> should be called with an  <code>IApiConnectionResponse</code> when your connector has received a response from the API.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s imagine that <code>responseHandler</code> is called when the platform&#8217;s response has arrived, and looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">c.responseHandler(new Handler&lt;ImaginaryResponse&gt; {
  public void handle(ImaginaryResponse response) {
	...
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is where we must build our apiman response, using the data returned in the platform&#8217;s response, and attaching appropriate handlers to capture any data that arrives.</p>
</div>
<div class="paragraph">
<p>In the following example, we expand the response <code>handle</code> method to build an <code>IApiConnectionResponse</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void handle(final ImaginaryResponse response) {

  IApiConnectionResponse readStream = new IApiConnectionResponse() {
    IAsyncHandler&lt;IApimanBuffer&gt; bodyHandler;
    IAsyncHandler&lt;IApimanBuffer&gt; endHandler;
    boolean finished = false;
    ApiResponse response = YourResponseBuilder.build(response);

    public IApiConnectionResponse() {
      doConnection();
    }

    private void doConnection() {
      // We stop any data arriving
      response.pause();

      // This will be called when we resume transmission
      response.bodyHandler(new Handler&lt;NativeDataChunk&gt;() {

        void handle(NativeDataChunk chunk) {
          IApimanBuffer apimanBuffer =
            new YourApimanBufferImpl(nativeBuffer);

          bodyHandler.handle(apimanBuffer);
        }
      });

      // Transmission has finished
      response.endHandler(new Handler&lt;Void&gt;() {

        void handle(Void flag) {
          endHandler.handle((Void) null);
          // You may want to close your backend connection here.
        }
      });
    }

    @Override
    public void bodyHandler(IAsyncHandler&lt;IApimanBuffer&gt; bodyHandler) {
      this.bodyHandler = bodyHandler;
    }

    @Override
    public void endHandler(IAsyncHandler&lt;Void&gt; endHandler) {
      this.endHandler = endHandler;
    }

    @Override
    public ApiResponse getHead() {
      return apiResponse;
    }

    @Override
    public boolean isFinished() {
      return finished;
    }

    @Override
    public void abort() {
      // Abort
    }

    // We explicitly resume transmission
    @Override
    public void transmit() {
      response.resume();
    }
  };

  // We're ready to transmit the response, let apiman know.
  IAsyncResult result = AsyncResultImpl.
    &lt;IApiConnectionResponse&gt; create(readStream);

  resultHandler.handle(result);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We imagine that our <code>response</code> object contains what we need to build a <code>ApiResponse</code>, and that handlers can be attached in order to retrieve body data and an end signal. It can be paused using <code>pause</code>, which prevents any data from arriving until <code>resume</code> is called.</p>
</div>
<div class="paragraph">
<p>Importantly, data transmission <strong>must not</strong> begin until <code>transmit</code> has been called, otherwise the appropriate handlers may not yet have been set, and data will be liable to disappear. Hence, in this example, <code>resume</code> is called in <code>transmit</code> where we are certain that it&#8217;s safe to send data.</p>
</div>
<div class="paragraph">
<p>After <code>end</code> has been signalled, clean up on the native connection can be performed, such as closing it. In this example was assume the connection is closed for us.</p>
</div>
<div class="paragraph">
<p>Once we are sure our stream is ready, we pass it to apiman using <code>resultHandler.handle</code> wrapped inside of an IAsyncResult indicating we were successful. Some helpful <code>create</code> methods are available in <code>AsyncResultImpl</code>.</p>
</div>
<div class="paragraph">
<p>Whilst a given platform&#8217;s implementation may look very different, implementors must be careful to preserve the same external behaviour; some platforms may require buffering of data if pause-like functionality is not available. In many cases it may be possible to implement <code>IApiConnectionResponse</code> and <code>IApiConnection</code> in the same class.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Do not transmit any response data into apiman until <code>transmit</code> has been signalled.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_handling_an_error"><a class="anchor" href="#_handling_an_error"></a>Handling an error</h5>
<div class="paragraph">
<p>If an error occurs, you must return a failure <code>IAsyncResult</code>, which may be caused, for instance, by an endpoint being unresolvable. The simplest way to share this is by using <code>AsyncResultImpl</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try { ... }
catch(Exception e) {
  IAsyncResult errorResult =
  	AsyncResultImpl.&lt;IApiConnectionResponse&gt; create(e);

  resultHandler.handle(errorResult);
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Remember to clean up any resources you may have left open.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_strategies"><a class="anchor" href="#_implementation_strategies"></a>Implementation strategies</h4>
<div class="paragraph">
<p>Implementors may notice that the only overlap between the <code>IApiConnection</code> and <code>IApiConnectionResponse</code> interfaces is the <code>isFinished</code> method. Hence, it is often possible to implement both interfaces using the same class, which may be a cleaner way to orchestrate the process.</p>
</div>
<div class="paragraph">
<p>Implementation exemplars:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/apiman/apiman/blob/master/gateway/platforms/servlet/src/main/java/io/apiman/gateway/platforms/servlet/connectors/HttpApiConnection.java">Servlet HTTP Connector</a> is a more traditional synchronous implementations.</p>
</li>
<li>
<p><a href="https://github.com/apiman/apiman/blob/master/gateway/platforms/vertx3/vertx3/src/main/java/io/apiman/gateway/platforms/vertx3/connector/HttpConnector.java">Vert.x 3 HTTP Connector</a> is an asynchronous HTTP implementation.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
